<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:security="http://www.springframework.org/schema/security"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context"
	xmlns:aop="http://www.springframework.org/schema/aop" xmlns:cache="http://www.springframework.org/schema/cache"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
						http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
						http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache.xsd
						http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd
						http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security.xsd"
	default-lazy-init="true">

	<!-- 启用@Secured注解 -->
	<security:global-method-security
		secured-annotations="enabled" />

	<!-- 定义的过滤器链 -->
	<!--org.springframework.security.web.FilterChainProxy 无法执行Filter接口的init方法 
		如果需要初始化 请使用spring的其他初始化接口 或者继承 GenericFilterBean这个抽象类, 实现initFilterBean() 
		throws ServletException这个方法可以初始化. 如果有问题请看源码. -->
	<bean id="filterChainProxy" class="org.springframework.security.web.FilterChainProxy">
		<security:filter-chain-map request-matcher="ant">
			<!-- 应用静态资源 -->
			<security:filter-chain pattern="/res/**"
				filters="characterEncodingFilter" />

			<!-- 登陆页面 -->
			<security:filter-chain pattern="/"
				filters="characterEncodingFilter" />

			<!-- 测试专用 -->
			<security:filter-chain pattern="/test/**"
				filters="characterEncodingFilter" />

			<!-- 常规过滤 -->
			<security:filter-chain pattern="/**"
				filters="characterEncodingFilter,
						securityContextPersistenceFilter, 
						logoutFilter,
						usernamePasswordAuthenticationFilter,
						securityContextHolderAwareRequestFilte,
						exceptionTranslationFilter,
						filterSecurityInterceptor
	 		" />
		</security:filter-chain-map>
	</bean>
	<!-- filters="characterEncodingFilter, -->
	<!-- localeChangedFilter, -->
	<!-- securityContextPersistenceFilter, -->
	<!-- logoutFilter, -->
	<!-- usernamePasswordAuthenticationFilter, -->
	<!-- securityContextHolderAwareRequestFilte, -->
	<!-- anonymousAuthenticationFilter, -->
	<!-- exceptionTranslationFilter, -->
	<!-- filterSecurityInterceptor -->

	<!-- 字符编码过滤器 -->
	<bean id="characterEncodingFilter" class="org.springframework.web.filter.CharacterEncodingFilter">
		<property name="encoding" value="UTF-8" />
		<property name="forceEncoding" value="true" />
	</bean>

	<!-- 用于封装servlet方法 -->
	<bean id="securityContextPersistenceFilter"
		class="org.springframework.security.web.context.SecurityContextPersistenceFilter">
		<property name="forceEagerSessionCreation" value="false" />
	</bean>

	<!-- 配置退出的过滤器信息 -->
	<bean id="logoutFilter"
		class="org.springframework.security.web.authentication.logout.LogoutFilter">
		<!-- 用户退出要转向的url -->
		<constructor-arg value="/" />
		<constructor-arg>
			<list>
				<bean
					class="org.springframework.security.web.authentication.logout.SecurityContextLogoutHandler" />
			</list>
		</constructor-arg>
		<!-- 要拦截的退出过请求url -->
		<property name="filterProcessesUrl" value="/loginout" />
	</bean>

	<!-- 登录验证过滤器 -->
	<bean id="usernamePasswordAuthenticationFilter"
		class="com.udf.security.authentication.UsernamePasswordAuthenticationFilter">
		<constructor-arg index="0">
			<value>/login</value>
		</constructor-arg>
		<property name="postOnly" value="true" />
		<property name="usernameParameter" value="username" />
		<property name="passwordParameter" value="password" />
		<property name="authenticationManager" ref="authenticationManager" />
		<property name="authenticationFailureHandler" ref="failureHandler" />
		<property name="authenticationSuccessHandler" ref="successHandler" />
	</bean>

	<bean id="authenticationManager"
		class="org.springframework.security.authentication.ProviderManager">
		<property name="eraseCredentialsAfterAuthentication" value="true" />
		<property name="providers">
			<list>
				<ref bean="daoAuthenticationProvider" />
			</list>
		</property>
	</bean>

	<bean id="daoAuthenticationProvider"
		class="com.udf.security.authentication.DaoAuthenticationProvider">
		<property name="saltSource" ref="saltSource" />
		<property name="UserDetailsService" ref="userDetailsService" />
		<property name="passwordEncoder" ref="passwordEncoder" />
	</bean>

	<bean id="saltSource"
		class="org.springframework.security.authentication.dao.ReflectionSaltSource">
		<property name="userPropertyToUse" value="username" />
	</bean>

	<bean id="userDetailsService" class="com.udf.pms.service.impl.UserService" />

	<bean id="passwordEncoder" class="com.udf.security.crypto.password.MD5SaltPasswordEncoder" />

	<bean id="successHandler"
		class="org.springframework.security.web.authentication.SavedRequestAwareAuthenticationSuccessHandler">
		<property name="defaultTargetUrl" value="/loginSuccess" />
		<property name="alwaysUseDefaultTargetUrl" value="true" />
	</bean>

	<bean id="failureHandler"
		class="org.springframework.security.web.authentication.SimpleUrlAuthenticationFailureHandler">
		<property name="useForward" value="true" />
		<property name="defaultFailureUrl" value="/loginFailed" />
	</bean>

	<bean name="securityContextHolderAwareRequestFilte"
		class="org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter" />

	<!-- <bean id="sessionManagementFilter" -->
	<!-- class="org.springframework.security.web.session.SessionManagementFilter"> -->
	<!-- <constructor-arg name="securityContextRepository" ref="securityContextRepository" 
		/> -->
	<!-- <property name="invalidSessionStrategy"> -->
	<!-- <bean -->
	<!-- class="org.springframework.security.web.session.SimpleRedirectInvalidSessionStrategy"> -->
	<!-- <constructor-arg name="invalidSessionUrl" -->
	<!-- value="/undicms/admin/sessionTimeout.do" /> -->
	<!-- </bean> -->
	<!-- </property> -->
	<!-- </bean> -->

	<!-- <bean id="securityContextRepository" -->
	<!-- class="org.springframework.security.web.context.HttpSessionSecurityContextRepository" 
		/> -->

	<bean id="exceptionTranslationFilter"
		class="org.springframework.security.web.access.ExceptionTranslationFilter">
		<property name="authenticationEntryPoint" ref="authenticationEntryPoint" />
		<property name="accessDeniedHandler" ref="accessDeniedHandler" />
	</bean>

	<bean id="authenticationEntryPoint"
		class="org.springframework.security.web.authentication.LoginUrlAuthenticationEntryPoint">
		<property name="loginFormUrl" value="/" />
	</bean>

	<bean id="accessDeniedHandler"
		class="org.springframework.security.web.access.AccessDeniedHandlerImpl">
		<property name="errorPage" value="/accessDenied" />
	</bean>

	<bean id="filterSecurityInterceptor"
		class="org.springframework.security.web.access.intercept.FilterSecurityInterceptor">
		<property name="authenticationManager" ref="authenticationManager" />
		<property name="accessDecisionManager" ref="accessDecisionManager" />
		<property name="securityMetadataSource" ref="securityMetadataSource" />
	</bean>

	<bean id="accessDecisionManager" class="org.springframework.security.access.vote.UnanimousBased">
		<property name="decisionVoters">
			<list>
				<ref bean="expressionVoter" />
			</list>
		</property>
	</bean>

	<!-- Service层会用到这个Handler 这里要配置一下 -->
	<!-- <bean id="expressionHandler" -->
	<!-- class="org.springframework.security.web.access.expression.DefaultWebSecurityExpressionHandler" 
		/> -->

	<!-- 使用自己的投票器，支持自己写的expressionConfigAttribute -->
	<bean id="expressionVoter" class="com.udf.security.authorization.ExpressionVoter" />

	<!-- <bean id="metaSourceRepository" class="com.udf.security.authorization.MetaSourceRepository" -->
	<!-- depends-on="resourceMappingService"> -->
	<!-- <property name="expressionHandler" ref="expressionHandler" /> -->
	<!-- </bean> -->

	<!-- 继承自ExpressionBasedFilterInvocationSecurityMetadataSource 支持从数据库读映射集合， -->
	<!-- 运行时修改映射集合 -->
	<bean id="securityMetadataSource"
		class="com.udf.security.authorization.DynamicSecurityMetaSource" />

	<bean
		class="org.springframework.security.web.access.DefaultWebInvocationPrivilegeEvaluator">
		<constructor-arg name="securityInterceptor" ref="filterSecurityInterceptor" />
	</bean>

</beans>
